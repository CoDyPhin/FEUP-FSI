
# LOGBOOK5
## Tasks 

### Task 1

The first task was an introduction to shellcode and its execution from the stack. After analysing the code, and with the notes provided about the instructions being executed from the shellcode, we understood that it would invoke an `execve` call to `/bin/sh`. In order to run the shell with root privileges, we would need to take the steps described in the **Environment Setup** section of the pdf. 
 - The first step was to disable the randomization of the starting address of the heap and the stack which is activated by default on Ubuntu systems. This randomization makes it harder to inject shellcode in the correct locations;
 - The second step was to make a symbolic link from `/bin/sh` (the program to be executed) to `zsh`. By default, `/bin/sh` is linked to `/bin/dash`, which has a countermeasure that prevents itself from being executed from a Set-UID process. On the other hand, the `zsh` shell doesn't have that countermeasure.

After compiling and running both versions, the program executed a shell (32-bit and 64-bit, respectively).

### Task 2
In this second task, we identified the potential buffer overflow vulnerability to be explored by the attacker: using `strcpy`(which doesn't check boundaries) to copy a buffer 517 bytes long into a buffer with size=`BUF_SIZE`. To compile the program we wrote the command `gcc -DBUF_SIZE=100 -m32 -o stack -z execstack -fno-stack-protector stack.c`. This command disables StackGuard and non-executable stack protections. Afterwards , we needed to make the executable generated by `gcc` a **Set-UID** program, to run as root.

### Task 3

The goal of this third task was to execute the attack that we setup in the previous task. 
The first step was to compile the `stack.c` code in debug mode using the **gdb** program. 
![](https://media.discordapp.net/attachments/579367639478960253/913554316143525908/unknown.png)
From this, we set a breakpoint on the `bof` function and identified the address of the **stack pointer** (`0xffffce38`) before it is modified to the stack frame of the bof() function. We also identified the address of the `buffer`(`0xffffcdcc`). From here, we calculated the distance between the buffer and the frame pointer (108). 
Therefore, we needed to edit the `exploit.py` in order to excute the attack with the correct addresses/values:
 - The `start` variable was set with 490 (517 - 27), as the shellcode had 27 characters and, this way it would be placed in the end of the buffer.
 - The `return` variable equals the address of the previous frame pointer + 200, to make sure that the program doesn't continue its normal execution.
 - The `offset` variable contains the value of the **return address**, which is the address that follows the frame pointer.
 
 Finally, after executing the program (with the Set-UID byte set), we were able to open a *zsh* shell with root privileges.
![](https://media.discordapp.net/attachments/579367639478960253/913561365191467008/unknown.png)

## CTF #5
### First challenge
The first step of this ctf challenge (after installing the necessary tools) was to run the `checksec` command to track the active protections of the program. 
By analysing the `main.c` code,  we could detect a buffer overflow vulnerability: the program opens a file whose name is stored in a buffer `meme_file` (with 8 bytes allocated) and asks for  an user input 28 characters long. The input is then copied (with **strcpy**) for a buffer with 20 bytes.  This allows a buffer overflow attack to overwrite the value of `meme_file` to "**flag.txt**", since the buffers occupy successive addresses, and thus reading the flag. In order to explore the vulnerability, we passed a user input with 20 "1"s concatenated with `flag.txt`: *"11111111111111111111flag.txt*". As expected, executing this attack on the server located at **ctf-fsi.fe.up.pt:4003** allowed us to retrieve the flag `flag{f043fb65ec047640dc3dce92e167be0f}`

### Second challenge
The second part of the ctf challenge is similar to the first one. The difference is that in this part, we have to inject an input that overwrites the `meme_file` value, as well the `val` buffer. This last buffer is 4 bytes long and, in order for file to be read, `val`needs to have the value `0xfefc2122`.  Since the buffers occupy successive addresses, we can launch a buffer overflow attack using the same logic as in the first challenge of this ctf. 
By inserting 20 characters ("1"s) followed by 'fefc2122' (hex) and **"flag.txt"**, we were able to read the content of the flag file. The input to be passed in the exploit is `11111111111111111111\x22\x21\xfc\xfeflag.txt`. The order needs to be taken into account, since `x22\x21\xfc\xfe` corresponds to `fefc2122` and is passed in reversed order. By running the attack on the server located at **ctf-fsi.fe.up.pt:4003** we were able to retrieve the flag `flag{32b67323a95112cc4575cbe463bbb222}`.# LOGBOOK5
## Tasks 

### Task 1

The first task was an introduction to shellcode and its execution from the stack. After analysing the code, and with the notes provided about the instructions being executed from the shellcode, we understood that it would invoke an `execve` call to `/bin/sh`. In order to run the shell with root privileges, we would need to take the steps described in the **Environment Setup** section of the pdf. 
 - The first step was to disable the randomization of the starting address of the heap and the stack which is activated by default on Ubuntu systems. This randomization makes it harder to inject shellcode in the correct locations;
 - The second step was to make a symbolic link from `/bin/sh` (the program to be executed) to `zsh`. By default, `/bin/sh` is linked to `/bin/dash`, which has a countermeasure that prevents itself from being executed from a Set-UID process. On the other hand, the `zsh` shell doesn't have that countermeasure.

After compiling and running both versions, the program executed a shell (32-bit and 64-bit, respectively).

### Task 2
In this second task, we identified the potential buffer overflow vulnerability to be explored by the attacker: using `strcpy`(which doesn't check boundaries) to copy a buffer 517 bytes long into a buffer with size=`BUF_SIZE`. To compile the program we wrote the command `gcc -DBUF_SIZE=100 -m32 -o stack -z execstack -fno-stack-protector stack.c`. This command disables StackGuard and non-executable stack protections. Afterwards , we needed to make the executable generated by `gcc` a **Set-UID** program, to run as root.

### Task 3

The goal of this third task was to execute the attack that we setup in the previous task. 
The first step was to compile the `stack.c` code in debug mode using the **gdb** program. 
![](https://media.discordapp.net/attachments/579367639478960253/913554316143525908/unknown.png)
From this, we set a breakpoint on the `bof` function and identified the address of the **stack pointer** (`0xffffce38`) before it is modified to the stack frame of the bof() function. We also identified the address of the `buffer`(`0xffffcdcc`). From here, we calculated the distance between the buffer and the frame pointer (108). 
Therefore, we needed to edit the `exploit.py` in order to excute the attack with the correct addresses/values:
 - The `start` variable was set with 490 (517 - 27), as the shellcode had 27 characters and, this way it would be placed in the end of the buffer.
 - The `return` variable equals the address of the previous frame pointer + 200, to make sure that the program doesn't continue its normal execution.
 - The `offset` variable contains the value of the **return address**, which is the address that follows the frame pointer.
 
 Finally, after executing the program (with the Set-UID byte set), we were able to open a *zsh* shell with root privileges.
![](https://media.discordapp.net/attachments/579367639478960253/913561365191467008/unknown.png)
### Task 4 (extra)
In this 4th task, we had to open a shell with root privileges without knowing the buffer size -  we only knew that it had a size between 100 and 200 bytes. In this case, the exploit would have to inject the return address in the first 200 bytes of the payload (to cover the case of the buffer being 200 bytes long). The **gdb** was still used in this task, however we didn't derive the distance between the buffer and the frame pointer from its investigation. Therefore, to exploit the vulnerability, we still had to inject the shellcode (32-bit version) 
in the end of the buffer. The start of the buffer was filled with the return address and the remaining content was filled with NOP operations.


## CTF #5
### First challenge
The first step of this ctf challenge (after installing the necessary tools) was to run the `checksec` command to track the active protections of the program. 
By analysing the `main.c` code,  we could detect a buffer overflow vulnerability: the program opens a file whose name is stored in a buffer `meme_file` (with 8 bytes allocated) and asks for  an user input 28 characters long. The input is then copied (with **strcpy**) for a buffer with 20 bytes.  This allows a buffer overflow attack to overwrite the value of `meme_file` to "**flag.txt**", since the buffers occupy successive addresses, and thus reading the flag. In order to explore the vulnerability, we passed a user input with 20 "1"s concatenated with `flag.txt`: *"11111111111111111111flag.txt*". As expected, executing this attack on the server located at **ctf-fsi.fe.up.pt:4003** allowed us to retrieve the flag `flag{f043fb65ec047640dc3dce92e167be0f}`

### Second challenge
The second part of the ctf challenge is similar to the first one. The difference is that in this part, we have to inject an input that overwrites the `meme_file` value, as well the `val` buffer. This last buffer is 4 bytes long and, in order for file to be read, `val`needs to have the value `0xfefc2122`.  Since the buffers occupy successive addresses, we can launch a buffer overflow attack using the same logic as in the first challenge of this ctf. 
By inserting 20 characters ("1"s) followed by 'fefc2122' (hex) and **"flag.txt"**, we were able to read the content of the flag file. The input to be passed in the exploit is `11111111111111111111\x22\x21\xfc\xfeflag.txt`. The order needs to be taken into account, since `x22\x21\xfc\xfe` corresponds to `fefc2122` and is passed in reversed order. By running the attack on the server located at **ctf-fsi.fe.up.pt:4003** we were able to retrieve the flag `flag{32b67323a95112cc4575cbe463bbb222}`.

